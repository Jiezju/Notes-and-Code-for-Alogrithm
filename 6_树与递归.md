## 二叉树天然的递归结构

- 递归程序的组成 
	
    ![](./img/90.png)
	![](./img/89.png)
    
- **1. 二叉树的最大深度**    
	![](./img/91.png)

	- 解题思路

		递归思路
        
    - 核心代码

		```C++
        int maxDepth(TreeNode* root) {
			if (root == NULL)
            	return 0;
                
            return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    	}
        ```
        
- **2. 翻转二叉树**

  ![](./img/92.png)
  
  - 解题思路

	递归算法，处理递归终止条件（节点为空），递归处理左右子树
    
   - 核心代码

		```C++
        TreeNode* invertTree(TreeNode* root) {
			if (root == NULL)
            	return NULL;
            
            invertTree(root->left);
            invertTree(root->right);
            swap(root->left, root->right);
            
            return root;
    	}
        ```

- **3. 路径总和**

	![](./img/94.png)
    
	- 解题思路

		注意到递归的终止条件是叶子结点
        
    - 核心代码

		```C++
        bool hasPathSum(TreeNode* root, int targetSum) {
			if (root == NULL)
            	return false;
     		if (root->left == NULL && root->right == NULL)
            	return root->val == targetSum;
            
            if (hasPathSum(root->left, targetSum - root->val))
            	return true;
            if (hasPathSum(root->right, targetSum - root->val))
            	return true;
                
            return false;
    	}
        ```
        
- **4. 二叉树的所有路径**     

	![](./img/95.png)
    
 - 解题思路

	递归向下直到叶子结点
	![](./img/96.png)  
    
    返回寻找组成答案
    ![](./img/97.png)  
    
 - 核心代码

	```C++
    vector<string> binaryTreePaths(TreeNode* root) {
		vector<string> res;
        
        if (root == NULL)
        	return res;
            
        if (root->left == NULL && root->right == NULL)
        {
        	res.push_back(to_string(root->val));
            return res;
        }
        
        vector<string> leftS = binaryTreePaths(root->left);
        for (int i=0; i < leftS.size(); ++i)
        	res.push_back(to_string(root->val) + "->" + leftS[i]);
            
        vector<string> rightS = binaryTreePaths(root->right);
        for (int i=0; i < rightS.size(); ++i)
        	res.push_back(to_string(root->val) + "->" + rightS[i]);
            
        return res;
    }
    ```