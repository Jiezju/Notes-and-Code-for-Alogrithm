## 动态规划

- 从 斐波那契 数列看动态规划

	- 递归实现

		```C++
        // 递归求斐波那契数列
        int fib( int n ){

            num ++;

            if( n == 0 )
                return 0;

            if( n == 1 )
                return 1;

            return fib(n-1) + fib(n-2);
        }
        ```
        
        递归实现的缺点在于存在大量重复计算，可以通过递归树查看
        
        ![](./img/118.png)
        
    - 记忆化搜索 - 自上而下解决问题   

		```
        vector<int> memo;
        memo = vector<int>(n + 1, -1);
        int num = 0;

        // 记忆化搜索
        int fib(int n){

            num ++;

            if(n == 0)
                return 0;

            if(n == 1)
                return 1;

			// 保存中间计算结果
            if(memo[n] == -1)
                memo[n] = fib(n - 1) + fib(n - 2);

            return memo[n];
        }
        ```
        
  - 动态规划 - 自下而上解决问题

	![](./img/119.png)
	```
    // 动态规划
    int fib( int n ){

        vector<int> memo(n + 1, -1);
		
        // 递归树的最底部
        memo[0] = 0;
        memo[1] = 1;
        for(int i = 2 ; i <= n ; i ++)
            memo[i] = memo[i - 1] + memo[i - 2];

        return memo[n];
    }
    ```