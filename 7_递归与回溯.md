## 递归与回溯

- **1. 电话号码的字母组合**

	![](./img/106.png)
    
    - 解题思路
    
    	树形问题，采用递归思想
        
        特点：从根节点开始到达叶子结点组成答案
        
        回溯法是暴力解法的主要实现手段
        
        ![](./img/107.png)
        
    - 解题代码

		```C++
        // 数字到字母的映射
        const string letterMap[10] = {
            " ",    //0
            "",     //1
            "abc",  //2
            "def",  //3
            "ghi",  //4
            "jkl",  //5
            "mno",  //6
            "pqrs", //7
            "tuv",  //8
            "wxyz"  //9
    	};
        
        vector<string> res;
        
        // s中保存了此时从digits[0...index-1]翻译得到的一个字母字符串
        // 找和digits[index]匹配的字母, 获得digits[0...index]翻译得到的解
        void findCombination(const string &digits, int index, const string &s){
        	if (index == digits.size()) {
            	res.push_back(s);
                return; // 这是返回上一个节点
            }
            
            char c = digits[index];
            string letters = letterMap[c- '0'];
            
            for (int i=0; i<letters.size(); ++i) {
            	findCombination(digits, index+1, s + letters[i]);
                // 回溯 递归找到答案或者没有找到，就会产生回溯
            }
       		
            return;
        }	
        
        vector<string> letterCombinations(string digits) {
        	res.clear();
            
            if (digits == "")
            	return res;
            
            // 
            findCombination(digits, 0, "");
            
            return res;
        }
        ```
        
- **2. 全排列**        

	![](./img/108.png)
    
    - 解题思路

		通过递归树，都是不断 “使用” 来进行递归
 
 		$$Permus(nums[0...n-1]) = \{取出一个数字\} + Permus(nums[0...n-1] - 去掉这个数字)$$
 
		![](./img/109.png)
        
    - 核心代码

		```C++
        vector<vector<int>> res;
    	vector<bool> used;
        
        // 全排列参数
        // nums 搜索的范围 index 标志 递归的层级，同时表示 index 之前的 nums 在之前已经考虑了 p 存储中间结果
        void generatePermutation(const vector<int>& nums, int index, vector<int>& p){
        	if (index == nums.size()) {
            	res.push_back(p);
                return;
            }
            
            for (int i=0; i<nums.size(); ++i) {
            	if (!used[i]) {
                	 used[i] = true;
                    p.push_back(nums[i]);
                    generatePermutation(nums, index + 1, p );
                    // 回溯状态返回
                    p.pop_back();
                    used[i] = false;
                }
           }
           
           return;
        }
        
        vector<vector<int>> permute(vector<int>& nums) {
        	res.clear();
            
            if(nums.size() == 0)
            	return res;
                
            used = vector<bool>(nums.size(), false);
            vector<int> p;
            generatePermutation(nums, 0, p);
            
            return res;
        }
        ```

- **2. 组合**

	 ![](./img/110.png)   
     
     - 解题思路
 
 		标注红色表明同样的递归流程
 		
        ![](./img/111.png)   
        
     - 解题思路

		```C++
        vector<vector<int>> res;
        
        // 求解C(n,k), 当前已经找到的组合存储在c中, 需要从start开始搜索新的元素
    	void generateCombinations(int n, int k, int start, vector<int> &c){
        	if (c.size() == k) {
            	res.push_back(c);
                return;
            }
            
            // 不能每次从头开始，需要继续向后遍历
            for (int i=start；i<=n;i++) {
            	c.push_back(i);
                generateCombinations(n, k, i+1, c);
                c.pop_back();
            }
            
            return;
        }	
        
        vector<vector<int>> combine(int n, int k) {
            res.clear();
            if( n <= 0 || k <= 0 || k > n )
                return res;

            vector<int> c;
            generateCombinations(n, k, 1, c);

            return res;
    	}
        ```

 - 解题优化

	回溯法的剪枝，比如在此问题中，最后一个取 4 实际上并不需要，具体如下
    
    ```C++
    // 此时 还需要 k - c.size() 个空位，所以 [i, n] 至少有 k - c.size() 个元素
    for (int i=start；i<=n- (k - c.size()) + 1;i++) {
        c.push_back(i);
        generateCombinations(n, k, i+1, c);
        c.pop_back();
    }
    ```