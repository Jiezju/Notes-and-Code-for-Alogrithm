## 递归与回溯

- **1. 电话号码的字母组合**

	![](./img/106.png)
    
    - 解题思路
    
    	树形问题，采用递归思想
        
        特点：从根节点开始到达叶子结点组成答案
        
        回溯法是暴力解法的主要实现手段
        
        ![](./img/107.png)
        
    - 解题代码

		```C++
        // 数字到字母的映射
        const string letterMap[10] = {
            " ",    //0
            "",     //1
            "abc",  //2
            "def",  //3
            "ghi",  //4
            "jkl",  //5
            "mno",  //6
            "pqrs", //7
            "tuv",  //8
            "wxyz"  //9
    	};
        
        vector<string> res;
        
        // s中保存了此时从digits[0...index-1]翻译得到的一个字母字符串
        // 找和digits[index]匹配的字母, 获得digits[0...index]翻译得到的解
        void findCombination(const string &digits, int index, const string &s){
        	if (index == digits.size()) {
            	res.push_back(s);
                return; // 这是返回上一个节点
            }
            
            char c = digits[index];
            string letters = letterMap[c- '0'];
            
            for (int i=0; i<letters.size(); ++i) {
            	findCombination(digits, index+1, s + letters[i]);
                // 回溯 递归找到答案或者没有找到，就会产生回溯
            }
       		
            return;
        }	
        
        vector<string> letterCombinations(string digits) {
        	res.clear();
            
            if (digits == "")
            	return res;
            
            // 
            findCombination(digits, 0, "");
            
            return res;
        }
        ```
        
- **2. 全排列**        

	![](./img/108.png)
    
    - 解题思路

		通过递归树，都是不断 “使用” 来进行递归
 
 		$$Permus(nums[0...n-1]) = \{取出一个数字\} + Permus(nums[0...n-1] - 去掉这个数字)$$
 
		![](./img/109.png)
        
    - 核心代码

		```C++
        vector<vector<int>> res;
    	vector<bool> used;
        
        void generatePermutation(const vector<int>& nums, int index, vector<int>& p){
        	if (index == nums.size()) {
            	res.push_back(p);
                return;
            }
            
            for (int i=0; i<nums.size(); ++i) {
            	if (!used[i]) {
                	 used[i] = true;
                    p.push_back(nums[i]);
                    generatePermutation(nums, index + 1, p );
                    // 回溯状态返回
                    p.pop_back();
                    used[i] = false;
                }
           }
           
           return res;
        }
        
        vector<vector<int>> permute(vector<int>& nums) {
        	res.clear();
            
            if(nums.size() == 0)
            	return res;
                
             used = vector<bool>(nums.size(), false);
            vector<int> p;
            generatePermutation(nums, 0, p);
            
            return res;
        }
        ```
    